// Programa de prueba de la clase ModbusServe

#define TITULO "ModbusTCP: Errores registros de salida."

#include <iostream>
#include <iomanip>
#include <vector>
#include <thread>
#include <chrono>
#include <cstring>      // std::strerror()

#include "Mensaje.hpp"
#include "ModbusTCP.hpp"

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>     // close()


int pruebas = 0;
int fallos = 0;

#define PUERTO 1502
#define ID_DEV  33
#define SERVER "127.0.0.1"
#define BUFLEN 512  // Longitud del buffer

bool servFin = false;

void ejecutaTCP(unsigned numClientes) {

  ModbusTCP mbTCP(PUERTO, ID_DEV);
  std::cout << "Creado servidor ModbusTCP" << std::endl;

  try {

    mbTCP.atiende(numClientes);

  } catch (std::runtime_error& e) {
    std::cerr << "Lanzada exception: " << e.what() << std::endl;
  }
  servFin = true;
}

void testea(int sfd, std::string titulo, Mensaje peticion,
    Mensaje respuestaOK) {

  pruebas++;

  std::cout << "\n\nTest '" << titulo << "' enviamos " << peticion.toString() << "\n";

  //metemos peticion en buffer
  uint8_t bufEnv[BUFLEN];
  for(unsigned int i=0; i<peticion.size(); i++)
    bufEnv[i] = peticion.getByteAt(i);

  int bsend = send(sfd, bufEnv, peticion.size(), 0);
  if(bsend == -1) {
    std::cerr << "Error al intentar send(): " << std::strerror(errno)
        << std::endl;
    return;
  }

  // recibimos respuesta
  uint8_t bufRec[BUFLEN];
  int recv_len;
  recv_len = recv(sfd, bufRec, BUFLEN, 0);
  if (recv_len == -1) {
    if((errno == EAGAIN) || (errno == EWOULDBLOCK)) {
      std::cout << "FALLO "  << ++fallos << ": Timeout esperando por la respuesta"
          << std::endl;
    } else {
      std::cerr << "Error al recibir datos: " << std::strerror(errno)
          << std::endl;
    }
    return;
  } else if (recv_len == 0) {
    std::cout << "Servidor cerró comunicaión" << std::endl;
    return;
  }

  //std::cout << "-> Recibido respuesta de "
      //<< recv_len << " bytes" << std::endl;
  Mensaje respuesta;
  for(int i = 0; i < recv_len; i++)
    respuesta.pushByte_back(bufRec[i]);
  //std::cout << "-> Datos: " << respuesta.toString() << std::endl;

  if(respuesta.toString() == respuestaOK.toString()) {
    std::cout << "CORRECTO: la respuesta fue " << respuesta.toString() << std::endl;
  } else {
    std::cout << "FALLO "  << ++fallos << ": la respuesta debería ser "
        << respuestaOK.toString() << " pero es " << respuesta.toString() << std::endl;
  }
}

int main (int argc, char *argv[]) {

  std::cout << "\n***  " << TITULO << "  ***\n" << std::endl;

  std::thread hiloModbusTCP(ejecutaTCP, 1);

  std::this_thread::sleep_for(std::chrono::seconds(1));

  //creamos socket TCP
  int sfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sfd == -1) {
    std::cerr << "Error al abrir el socket: " << std::strerror(errno)
        << std::endl;
    return 200;
  }

  // Ponemos timeout de receptción
  struct timeval tv;
  tv.tv_sec = 1;
  tv.tv_usec = 0;
  setsockopt(sfd, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof tv);

  struct sockaddr_in si_otro;
  unsigned slen = sizeof(struct sockaddr_in);

  si_otro.sin_family = AF_INET;
  si_otro.sin_port = htons(PUERTO);
  inet_aton(SERVER , &si_otro.sin_addr);

  //Conectamos al servidor
  int conn = connect(sfd, (struct sockaddr *) &si_otro, slen);
  if( conn == -1 ) {
    std::cerr << "Error al conectar con servidor: " << std::strerror(errno)
        << std::endl;
    close(sfd);
    hiloModbusTCP.join();
    return 201;
  }

  {
    Mensaje peti({ 0x00, 0x34, 0x00, 0x00, 0x00, 0x06, 0x21, 0x07, 0x00, 0x21, 0x00, 0x33 });
    Mensaje resp({ 0x00, 0x34, 0x00, 0x00, 0x00, 0x03, 0x21, 0x87, 0x01 });
    testea(sfd, "Funcion inválida", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x35, 0x00, 0x00, 0x00, 0x06, 0x21, 0x09, 0x00, 0x63, 0x03, 0xE8 });
    Mensaje resp({ 0x00, 0x35, 0x00, 0x00, 0x00, 0x03, 0x21, 0x89, 0x01 });
    testea(sfd, "Funcion inválida", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x36, 0x00, 0x00, 0x00, 0x06, 0x21, 0x03, 0x00, 0x0A, 0x00, 0x01 });
    Mensaje resp({ 0x00, 0x36, 0x00, 0x00, 0x00, 0x03, 0x21, 0x83, 0x02 });
    testea(sfd, "Error, lectura analogica en 11", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x37, 0x00, 0x00, 0x00, 0x06, 0x21, 0x03, 0x00, 0x09, 0x00, 0x06 });
    Mensaje resp({ 0x00, 0x37, 0x00, 0x00, 0x00, 0x03, 0x21, 0x83, 0x02 });
    testea(sfd, "Error, lectura analogica de 10 a 15", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x38, 0x00, 0x00, 0x00, 0x06, 0x21, 0x03, 0x00, 0x00, 0x00, 0x0B });
    Mensaje resp({ 0x00, 0x38, 0x00, 0x00, 0x00, 0x03, 0x21, 0x83, 0x02 });
    testea(sfd, "Error, lectura analogica de 1 a 11", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x39, 0x00, 0x00, 0x00, 0x06, 0x21, 0x01, 0x00, 0x14, 0x00, 0x01 });
    Mensaje resp({ 0x00, 0x39, 0x00, 0x00, 0x00, 0x03, 0x21, 0x81, 0x02 });
    testea(sfd, "Error, Leemos las salida digital 21", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x3A, 0x00, 0x00, 0x00, 0x06, 0x21, 0x01, 0x00, 0x00, 0x00, 0x15 });
    Mensaje resp({ 0x00, 0x3A, 0x00, 0x00, 0x00, 0x03, 0x21, 0x81, 0x02 });
    testea(sfd, "Error, Leemos las salida digital de 1 a 21", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x3B, 0x00, 0x00, 0x00, 0x06, 0x21, 0x01, 0x00, 0x0E, 0x00, 0x0B });
    Mensaje resp({ 0x00, 0x3B, 0x00, 0x00, 0x00, 0x03, 0x21, 0x81, 0x02 });
    testea(sfd, "Error, Leemos las salida digital de 15 a 25", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x3C, 0x00, 0x00, 0x00, 0x06, 0x21, 0x05, 0x00, 0x14, 0xFF, 0x00 });
    Mensaje resp({ 0x00, 0x3C, 0x00, 0x00, 0x00, 0x03, 0x21, 0x85, 0x02 });
    testea(sfd, "Error, escritura digital única en 21", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x3D, 0x00, 0x00, 0x00, 0x06, 0x21, 0x05, 0x00, 0x31, 0xFF, 0x00 });
    Mensaje resp({ 0x00, 0x3D, 0x00, 0x00, 0x00, 0x03, 0x21, 0x85, 0x02 });
    testea(sfd, "Error, escritura digital única en 50", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x3E, 0x00, 0x00, 0x00, 0x08, 0x21, 0x0F, 0x00, 0x14, 0x00, 0x01, 0x01, 0x01 });
    Mensaje resp({ 0x00, 0x3E, 0x00, 0x00, 0x00, 0x03, 0x21, 0x8F, 0x02 });
    testea(sfd, "Error, escritura digital multiple en 21", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x3F, 0x00, 0x00, 0x00, 0x0A, 0x21, 0x0F, 0x00, 0x00, 0x00, 0x15, 0x03, 0x00, 0x00, 0x00 });
    Mensaje resp({ 0x00, 0x3F, 0x00, 0x00, 0x00, 0x03, 0x21, 0x8F, 0x02 });
    testea(sfd, "Error, escritura digital multiple de 1 a 21", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x40, 0x00, 0x00, 0x00, 0x09, 0x21, 0x0F, 0x00, 0x09, 0x00, 0x10, 0x02, 0x00, 0x00 });
    Mensaje resp({ 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x21, 0x8F, 0x02 });
    testea(sfd, "Error, escritura digital multiple de 10 a 25", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x41, 0x00, 0x00, 0x00, 0x06, 0x21, 0x06, 0x00, 0x0A, 0x00, 0x01 });
    Mensaje resp({ 0x00, 0x41, 0x00, 0x00, 0x00, 0x03, 0x21, 0x86, 0x02 });
    testea(sfd, "Error, estritura analogica única en 11", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x42, 0x00, 0x00, 0x00, 0x06, 0x21, 0x06, 0x00, 0x1D, 0x00, 0x01 });
    Mensaje resp({ 0x00, 0x42, 0x00, 0x00, 0x00, 0x03, 0x21, 0x86, 0x02 });
    testea(sfd, "Error, estritura analogica única en 30", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x43, 0x00, 0x00, 0x00, 0x09, 0x21, 0x10, 0x00, 0x0A, 0x00, 0x01, 0x02, 0x00, 0x01 });
    Mensaje resp({ 0x00, 0x43, 0x00, 0x00, 0x00, 0x03, 0x21, 0x90, 0x02 });
    testea(sfd, "Error, escritura analogica múltiple en 11", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x44, 0x00, 0x00, 0x00, 0x1D, 0x21, 0x10, 0x00, 0x00, 0x00, 0x0B, 0x16, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0A, 0x00, 0x0B });
    Mensaje resp({ 0x00, 0x44, 0x00, 0x00, 0x00, 0x03, 0x21, 0x90, 0x02 });
    testea(sfd, "Error, escritura analogica múltiple de 1 a 11", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x45, 0x00, 0x00, 0x00, 0x27, 0x21, 0x10, 0x00, 0x04, 0x00, 0x10, 0x20, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0A, 0x00, 0x0B, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x0E, 0x00, 0x0F, 0x00, 0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00, 0x14 });
    Mensaje resp({ 0x00, 0x45, 0x00, 0x00, 0x00, 0x03, 0x21, 0x90, 0x02 });
    testea(sfd, "Error, escritura analogica múltiple de 5 a 20", peti, resp);
  }


// Errores mal formados salidas

  {
    Mensaje peti({ 0x00, 0x46, 0x00, 0x00, 0x00, 0x02, 0x21, 0x03 });
    Mensaje resp({ 0x00, 0x46, 0x00, 0x00, 0x00, 0x03, 0x21, 0x83, 0x03 });
    testea(sfd, "Leer salidas analogicas NO tamaño mínimo", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x47, 0x00, 0x00, 0x00, 0x05, 0x21, 0x03, 0x00, 0x00, 0x00 });
    Mensaje resp({ 0x00, 0x47, 0x00, 0x00, 0x00, 0x03, 0x21, 0x83, 0x03 });
    testea(sfd, "Leer salidas analogicas mal formado (tamaño incorrecto)", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x48, 0x00, 0x00, 0x00, 0x02, 0x21, 0x01 });
    Mensaje resp({ 0x00, 0x48, 0x00, 0x00, 0x00, 0x03, 0x21, 0x81, 0x03 });
    testea(sfd, "Leer salidas digitales NO tamaño mínimo", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x49, 0x00, 0x00, 0x00, 0x05, 0x21, 0x01, 0x00, 0x00, 0x00 });
    Mensaje resp({ 0x00, 0x49, 0x00, 0x00, 0x00, 0x03, 0x21, 0x81, 0x03 });
    testea(sfd, "Leer salidas digitales mal formado (tamaño incorrecto)", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x4A, 0x00, 0x00, 0x00, 0x06, 0x21, 0x05, 0x00, 0x01, 0xFF, 0xFF });
    Mensaje resp({ 0x00, 0x4A, 0x00, 0x00, 0x00, 0x03, 0x21, 0x85, 0x03 });
    testea(sfd, "Forzamos única salida digital 1 con valor incorrecto FF FF", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x4B, 0x00, 0x00, 0x00, 0x06, 0x21, 0x05, 0x00, 0x05, 0x01, 0x00 });
    Mensaje resp({ 0x00, 0x4B, 0x00, 0x00, 0x00, 0x03, 0x21, 0x85, 0x03 });
    testea(sfd, "Forzamos única salida digital 5 con valor incorrecto 01 00", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x4C, 0x00, 0x00, 0x00, 0x05, 0x21, 0x05, 0x00, 0x03, 0xFF });
    Mensaje resp({ 0x00, 0x4C, 0x00, 0x00, 0x00, 0x03, 0x21, 0x85, 0x03 });
    testea(sfd, "Forzamos única salida digital tamaño incorrecto", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x4D, 0x00, 0x00, 0x00, 0x02, 0x21, 0x05 });
    Mensaje resp({ 0x00, 0x4D, 0x00, 0x00, 0x00, 0x03, 0x21, 0x85, 0x03 });
    testea(sfd, "Forzamos única salida digital tamaño incorrecto", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x4E, 0x00, 0x00, 0x00, 0x02, 0x21, 0x0F });
    Mensaje resp({ 0x00, 0x4E, 0x00, 0x00, 0x00, 0x03, 0x21, 0x8F, 0x03 });
    testea(sfd, "Escribimos varias digitales NO tamaño mínimo", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x4F, 0x00, 0x00, 0x00, 0x0A, 0x21, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x00, 0xAA, 0xAA, 0x0A });
    Mensaje resp({ 0x00, 0x4F, 0x00, 0x00, 0x00, 0x03, 0x21, 0x8F, 0x03 });
    testea(sfd, "Escribimos varias digitales num. datos y num. posiciones no coinciden", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x50, 0x00, 0x00, 0x00, 0x09, 0x21, 0x0F, 0x00, 0x00, 0x00, 0x14, 0x03, 0xAA, 0xAA });
    Mensaje resp({ 0x00, 0x50, 0x00, 0x00, 0x00, 0x03, 0x21, 0x8F, 0x03 });
    testea(sfd, "Escribimos varias digitales numero datos incorrecto", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x51, 0x00, 0x00, 0x00, 0x02, 0x21, 0x10 });
    Mensaje resp({ 0x00, 0x51, 0x00, 0x00, 0x00, 0x03, 0x21, 0x90, 0x03 });
    testea(sfd, "Escribimos varias analogicas NO tamaño mínimo", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x52, 0x00, 0x00, 0x00, 0x0B, 0x21, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x02 });
    Mensaje resp({ 0x00, 0x52, 0x00, 0x00, 0x00, 0x03, 0x21, 0x90, 0x03 });
    testea(sfd, "Escritura analogica múltiple  num. datos y num. posiciones no coinciden", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x53, 0x00, 0x00, 0x00, 0x1C, 0x21, 0x10, 0x00, 0x00, 0x00, 0x0B, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00, 0x09, 0x00 });
    Mensaje resp({ 0x00, 0x53, 0x00, 0x00, 0x00, 0x03, 0x21, 0x90, 0x03 });
    testea(sfd, "Escritura analogica múltiple  num. datos insuficientes", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x54, 0x00, 0x00, 0x00, 0x02, 0x21, 0x06 });
    Mensaje resp({ 0x00, 0x54, 0x00, 0x00, 0x00, 0x03, 0x21, 0x86, 0x03 });
    testea(sfd, "Escribimos unica analogicas NO tamaño mínimo", peti, resp);
  }
  {
    Mensaje peti({ 0x00, 0x55, 0x00, 0x00, 0x00, 0x05, 0x21, 0x06, 0x00, 0x00, 0x0B });
    Mensaje resp({ 0x00, 0x55, 0x00, 0x00, 0x00, 0x03, 0x21, 0x86, 0x03 });
    testea(sfd, "Escribimos unica analogicas faltan bytes", peti, resp);
  }

  close(sfd);
  std::this_thread::sleep_for(std::chrono::seconds(1));
  if (servFin)  hiloModbusTCP.join();
  else {
    std::cout << "FALLO "  << ++fallos << ": el servidor no terminó tras 1 cliente"
        << std::endl;
  }

  // Resumen final
  if (fallos == 0)
    std::cout << "\n :-) Todas las " << pruebas << " pruebas correctas\n"
        << std::endl;
  else
    std::cout << "\n :-( Se han producido " << fallos << " FALLOs de "
        << pruebas << " pruebas (" << std::fixed <<  std::setprecision(0)
        << fallos*100.0/pruebas << "%)\n"
        << std::endl;
  return fallos;
}
